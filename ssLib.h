// state space element
typedef struct SSel_TAG {
	struct SSel_TAG *parent;		// parent node of the state element
	struct SSel_TAG *sibling;		// next sibling of the state element
	struct SSel_TAG *firstChild;	// first child of the state element
	int size;						// total number of leaf starting from this point
									// for the leaf, it holds the id of the state
	int val;						// value of this state element
} SSel;

// state space struct
typedef struct {
	int levels;		// levels of the state state
	int size;		// current number of states
	SSel *root;		// root element of the state space
	int *decTab;	// decoding table to help in decoding the state
} StateSpace;


// output structure for a state transition constrution
typedef struct OutState_TAG {
	int *stDef;					// state definition
	double rate;				// double rate
	struct OutState_TAG *next;	// next element of the output transitions
} OutState;

// internal structure to build the transition matrix
typedef struct MatElRCR_TAG {
	int row;					// row of the element
	int col;					// column of the element
	double rate;				// rate of the element
	struct MatElRCR_TAG *next;	// next element of the matrix
} MatElRCR;


//////////// Prototypes ////////////

// creates and returns a state space of <levels> different components
StateSpace *CreateStateSpace(int levels);
// creates and returns a state space element with the given value
SSel *CreateSSel(int val);
// destroy a state space element and all its descendant and relatives
void DestroySSel(SSel *ssel);
// destroy a state space
void DestroyStateSpace(StateSpace *ss);

// finds the id of a state, or return -1 if it does not exists
int FindState(StateSpace *ss, int *vals);
// creates a new state and returns its id
int NewState(StateSpace *ss, int *vals);
// looks for a state in the state space: if found, retunrs its id, otherwise creates a new one
int GetState(StateSpace *ss, int *vals);
// finalizes the state space. This function must be called at the end of
// the state space generation. After this, the deconding of the state space
// will be available
void FinalizeStateSpace(StateSpace *ss);
// returns the definition of the state with a given number
// returns 0 if the state does not exists, 1 otherwise
int DecodeState(StateSpace *ss, int id, int *vals);

// Creates a new next state for a transition
// The <stDef> array, encodes the state. It must be an array that will be used
// and deallocated by the procedure
OutState *CreateNextState(int *stDef, double rate, OutState *next);
// Destroy a list of state transitions. If next it is not null, it recursively destroy
// the element of the list
void DestroyOutState(OutState *OSt);
// Creates a new element for the out matrix list
MatElRCR *CreateMatElRCR(int row, int col, double rate, MatElRCR *next);
// Destroy the out matrix list. If next it is not null, it recursively destroy
// the element of the list
void DestroyMatElRCR(MatElRCR *Mlist);


// Create a model with the state of <levels> levels, and initial state
// described by <initialState>. The procedure gets a pointe to model definition data <M>
// The transition will be generated by function
//
// OutState *transFunc(int *st, void *M) { ... }
//
//    the parameter passed to the function are the state definition <st> and the
//    model definition that was passed in pointer <M>.
//    The function returns the out transition from state <st> encoded in the list of type
//    OutState * returned by the function. Each node of the list, contains the definition
//    of the next state, and the corresponding transition rate.
//    GenerateModelMatrix automatically frees the elements of OutState during it execution
//
// The function returns the model matrix, and the state space if <outSS> != NULL
//
Matrix *GenerateModelMatrix(int levels, 
							OutState *(*transFunc)(int *, void *),
						    int *initialState, void *M, StateSpace **outSS);

